class Jarmo

types

instance variables
-- Jogador 1 : Branco - começa em cima
-- Jogador 2 : Preto - começa em baixo
 public jogadores: set of Player;
 	inv card jogadores = 2;
 public tabuleiro: set of Posicao;
 public jogadorAtual : Player;
 public jogadorAdversario: Player;
 public vencedor: Player;
 
 public recupera_jog: bool;
 
 public pontuacao : map Player to nat1 := {|->};
 public pontos : set of nat1;
	
operations
		public Jarmo : () ==> Jarmo
			Jarmo() == (
			-- Posicao (x,y,ocupado)
		
		-- Primeira linha
		dcl p1: Posicao := new Posicao(0,0,1);
		dcl p2: Posicao := new Posicao(1,0,1);
		dcl p3: Posicao := new Posicao(2,0,1);
		dcl p4: Posicao := new Posicao(3,0,1);
		dcl p5: Posicao := new Posicao(4,0,1);
		
		-- Segunda linha
		dcl p6: Posicao := new Posicao(0,1,0);
		dcl p7: Posicao := new Posicao(1,1,0);
		dcl p8: Posicao := new Posicao(2,1,0);
		dcl p9: Posicao := new Posicao(3,1,0);
		dcl p10: Posicao := new Posicao(4,1,0);
		
		-- Terceira linha
		dcl p11: Posicao := new Posicao(0,2,0);
		dcl p12: Posicao := new Posicao(1,2,0);
		dcl p13: Posicao := new Posicao(2,2,0);
		dcl p14: Posicao := new Posicao(3,2,0);
		dcl p15: Posicao := new Posicao(4,2,0);
		
		-- Quarta linha
		dcl p16: Posicao := new Posicao(0,3,0);
		dcl p17: Posicao := new Posicao(1,3,0);
		dcl p18: Posicao := new Posicao(2,3,0);
		dcl p19: Posicao := new Posicao(3,3,0);
		dcl p20: Posicao := new Posicao(4,3,0);
		
		-- Quinta linha
		dcl p21: Posicao := new Posicao(0,4,2);
		dcl p22: Posicao := new Posicao(1,4,2);
		dcl p23: Posicao := new Posicao(2,4,2);
		dcl p24: Posicao := new Posicao(3,4,2);
		dcl p25: Posicao := new Posicao(4,4,2);
		
		dcl pl1: Player;
		dcl pl2: Player;
		
		-- Definir adjacentes
		p1.setAdjacentes({p12,p8});
		p2.setAdjacentes({p11,p9});
		p3.setAdjacentes({p6,p12,p10});
		p4.setAdjacentes({p7,p15});
		p5.setAdjacentes({p8,p14});
		p6.setAdjacentes({p3,p13});
		p7.setAdjacentes({p4,p8,p14,p12});
		p8.setAdjacentes({p1,p5,p17,p7,p9});
		p9.setAdjacentes({p2,p8,p14,p20});
		p10.setAdjacentes({p3,p13});
		p11.setAdjacentes({p2,p22});
		p12.setAdjacentes({p1,p7,p3,p19,p17,p21});
		p13.setAdjacentes({p6,p10,p16,p24});
		p14.setAdjacentes({p7,p9,p5,p25,p19});
		p15.setAdjacentes({p4,p18});
		p16.setAdjacentes({p13,p23});
		p17.setAdjacentes({p12,p8,p18,p24});
		p18.setAdjacentes({p17,p15,p19,p25,p21});
		p19.setAdjacentes({p22,p18,p12,p14});
		p20.setAdjacentes({p23,p9});
		p21.setAdjacentes({p12,p18});
		p22.setAdjacentes({p11,p19});
		p23.setAdjacentes({p16,p14,p20});
		p24.setAdjacentes({p17,p13});
		p25.setAdjacentes({p18,p14});
		
		tabuleiro := {p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25};

		pl1 := new Player(['B','r','a','n','c','o'], p1,p2,p3,p4,p5);
		pl2 := new Player(['P','r','e','t','o'], p21,p22,p23,p24,p25);
		jogadores:= {pl1,pl2};
		jogadorAtual := pl1;
		jogadorAdversario := pl2;
		return self;
		);

		-- get turno
		public getTurno : () ==> Player
			getTurno() == (return jogadorAtual;);
		
		-- get Tabuleiro
		public getTabuleiro: () ==> set of Posicao
			getTabuleiro() == (return tabuleiro;);

		-- Mudar de turno
		public MudarTurno : () ==> ()
			MudarTurno() == (
			jogadorAtual := iota s in set jogadores & s <> jogadorAtual;
			jogadorAdversario := iota q in set jogadores & q <> jogadorAtual;);
			
		
	 -- game over : quando termina o jogo
	pure public gameOver: () ==> bool
			gameOver() == (
				dcl res: bool := true;
				if (jogadorAtual.cor = ['B','r','a','n','c','o']) then (
					for all arq in set jogadorAtual.arqueiros do
								if ( arq.vivo = <True> and arq.posicao.getY() <> 4) then 
									res:= false;)
					else
					for all arq in set jogadorAtual.arqueiros do
								if ( arq.vivo = <True> and arq.posicao.getY() <> 0) then 
									res:= false;
									
					return res;);
			
			-- verfifica se posicao esta ocupada
				public verifica_pos: Posicao ==> bool 
					verifica_pos(posicao) == (
						return posicao.getOcupado() <> 0
					)
					pre posicao in set tabuleiro;

					
				
				-- pos_nova nao pode estar ocupada por amigo

			--verifica com o que a posiçao esta ocupada
			public verifica_posicao: Posicao ==> nat
				verifica_posicao(pos) == (
					return pos.getOcupado();
				)
				pre pos in set tabuleiro;
				
				--verificar se a posiçao nova é adjacente da atual
				public verificar_adjacente: Posicao * Posicao ==> bool
				verificar_adjacente(pos_atual, pos_nova) == (
						return (pos_nova in set pos_atual.adjacentes));			
				
				
				public contaPontos: () ==> ()
				contaPontos() == (
				
					dcl pontos_aux : nat1;	
 					dcl pontuacao_aux : map Player to nat1;
 					dcl vencedor_aux : set of Player;
					pontos_aux := 1;
					for all p in set jogadores do (
						pontuacao:= pontuacao++{p |->  p.contaPontos()};
					);
					pontos := rng pontuacao;
					for all p in set pontos do (
						if(pontos_aux < p) then 
							pontos_aux:=p;
					);
					
					pontuacao_aux := pontuacao:> {pontos_aux};
					vencedor_aux := dom pontuacao_aux;
					for all v in set vencedor_aux do(
						vencedor := v;
					)
				);
				
				
				
				-- Adicionar parametros jogador e nova pos para teste
				-- Quando posicao é escolhida tem que ser copiada na integra. Ocupado tbm!
				
				-- 
				public jogada: Arqueiro * Posicao ==> bool
					jogada(arq_a_mover, pos_nova) == (
					dcl posicoes: set of Posicao;
					if(jogadorAtual.cor = ['B','r','a','n','c','o']) then (
		 			dcl p1: Posicao := new Posicao (0,0,0);
		 			dcl p2: Posicao := new Posicao (1,0,0);
		 			dcl p3: Posicao := new Posicao (2,0,0);
		 			dcl p4: Posicao := new Posicao (3,0,0);
		 			dcl p5: Posicao := new Posicao (4,0,0);
		 			posicoes := {tabPos(p1),tabPos(p2),tabPos(p3),tabPos(p4),tabPos(p5)};
		 		)
		 		else (
		 			dcl p1: Posicao := new Posicao (0,4,0);
		 			dcl p2: Posicao := new Posicao (1,4,0);
		 			dcl p3: Posicao := new Posicao (2,4,0);
		 			dcl p4: Posicao := new Posicao (3,4,0);
		 			dcl p5: Posicao := new Posicao (4,4,0);
		 			posicoes := {tabPos(p1),tabPos(p2),tabPos(p3),tabPos(p4),tabPos(p5)};
		 		);
							
						--verifica se a posicao nova é adjacente da actual
						
						-- verificaçao na funçao que da a pos e nao aqui
						--cancelar o move ou nao deixar fazer o move se a posicao for ocupado por um arqueiro da mesma team
						if (jogadorAtual.cor = ['B','r','a','n','c','o']) then (
							if(verifica_posicao(pos_nova) = 1) then (
								return false;))
						else (
							if(verifica_posicao(pos_nova) = 2) then (
								return false; )
						);
											
						-- Escolher jogador a recuperar se for o caso --A posiçao nova tem um arqueiro inimigo
						if(verifica_pos(pos_nova)) then (
				
							jogadorAtual.marcaArqueiro(arq_a_mover);
							jogadorAdversario.mataArqueiro(pos_nova);

							);
								
							
						-- desocupar posicao antiga 
						jogadorAtual.desocupaPos(arq_a_mover);
											
						
						jogadorAtual.novaPos(arq_a_mover, pos_nova);
						
						-- Se matou e chegou à ultima posicao entao pode recuperar um morto
							if (jogadorAtual.cor = ['B','r','a','n','c','o']) then (
								
									--jogadorAtual.ocupaPosBranco(pos_nova);
								if(arq_a_mover.marcado = <True>) then(
								 (if(pos_nova.getY() = 4) then
								 		if(jogadorAtual.reporArqueiroMorto(posicoes)) then jogadorAtual.desmarcaArqueiro(arq_a_mover);
								 		)))
									--recupera_jog := true;)))
							else(
								--	jogadorAtual.ocupaPosPreto(pos_nova);
									if(arq_a_mover.marcado = <True>) then(
								 (if(pos_nova.getY() = 0) then
									if(jogadorAtual.reporArqueiroMorto(posicoes)) then jogadorAtual.desmarcaArqueiro(arq_a_mover);
								 		)));
									--recupera_jog := true;)));
						
						
						MudarTurno();
						return true;)
						pre not gameOver()
						and arq_a_mover in set jogadorAtual.arqueiros and
						pos_nova in set arq_a_mover.posicao.adjacentes and
						pos_nova in set tabuleiro;

					
					
					-- retorna posicao do tabuleiro igual a parametro
					
					public tabPos: Posicao ==> Posicao
						tabPos(pos) == (
							return	iota s in set tabuleiro & s.getX() = pos.getX() and s.getY() = pos.getY();
					);
					
					
					
			
		
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Jarmo